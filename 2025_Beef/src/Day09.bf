namespace _2025_Beef;

using System;
using System.Collections;

class Day09
{
	struct Position
	{
		public uint32 x;
		public uint32 y;

		public this
		{
			x = 0;
			y = 0;
		}

		public this(uint32 xin, uint32 yin)
		{
			x = xin;
			y = yin;
		}
	}

	static bool IsInside(Position min, Position max, Position pos)
	{
		bool x = (pos.x < max.x) && (pos.x > min.x);
		bool y = (pos.y < max.y) && (pos.y > min.y);
		return x && y;
	}

	static bool HasPointInside(List<Position> positions, int64 i, int64 j)
	{
		Position a = positions[i];
		Position b = positions[j];

		Position max;
		max.x = Math.Max(a.x, b.x);
		max.y = Math.Max(a.y, b.y);

		Position min;
		min.x = Math.Min(a.x, b.x);
		min.y = Math.Min(a.y, b.y);

		for (uint32 k = 0; k < positions.Count; k++)
		{
			if (k == i || k == j)
			{
				continue;
			}

			Position c = positions[k];
			if (IsInside(min, max, c))
			{
				return true;
			}

			// this is an exception case (that caused my solution to be bad, so
			// it is not so exceptional)
			// When a segment is aligned with the box test and both sides align,
			// it is certain that part of the box is outside the shape, thus, we
			// should test against segments too.

			// For example, the flagged edge is problematic:
			// |-------|
			// |	   |
			// |--|    |----|
			//    |---------|

			// The biggest should be as on the left but is detected as on the right:
			// XXXXXXXXX			XXXXXXXXXXXXXX
			// XXXXXXXXX			XXXXXXXXXXXXXX
			// XXXXXXXXX----|		XXXXXXXXXXXXXX
			//    |---------|		   |---------|

			// This is because the edge on the right of our shape has no point inside
			// the box. Using the center of edges tracks a bunch of those, but there
			// are cases where this is not sufficient. Luckily enough the shape we
			// get in the problem is fair and this test was enough to catch the remaining
			// bad boxes. I won't fix those since it can solve the puzzle (at least
			// the one I got) with just this additional test.

			Position n = positions[(k + 1) % positions.Count];
			var mid = Position((n.x + c.x) / 2,  (n.y + c.y) / 2);
			if (IsInside(min, max, mid))
			{
				return true;
			}
		}

		return false;
	}

	static int64 RectangleSize(Position a, Position b)
	{
		int64 dim_x = Math.Abs(a.x - b.x) + 1;
		int64 dim_y = Math.Abs(a.y - b.y) + 1;
		return dim_x * dim_y;
	}

	static int64 ComputeMaximumDimension(List<Position> positions, bool isPartB)
	{
		int64 max = 0;

		for (uint32 i = 0; i < positions.Count; i++)
		{
			for (uint32 j = i + 1; j < positions.Count; j++)
			{
				int64 dim = RectangleSize(positions[i], positions[j]);

				// for case B, if the rectangle has any other point inside it cannot
				// be valid, since the point will always cause he rectangle to become invalid

				// in real-life cases, this algorithm would not be sufficient since we assume
				// there could not be a huge rectangle generated by 3 points towards the exterior
				// of the shape. In the following example, the biggest triangle would be
				// the BIG one, and it would be oustide of the shape.
				// |--------|
				// | |------|
				// | |
				// | |  BIG
				// |-|

				// We thus assume the shape is somewhat "circular" and has a large interior.
				// Otherwise we would need to find the inside of the shape, and flag the outside
				// and inside of each segment and detect the situation above.

				if (dim > max && (!isPartB || !HasPointInside(positions, i, j)))
				{
					max = dim;
				}
			}
		}

		return max;
	}

	static public void Execute(List<String> lines, bool isPartB)
	{
		var positions = scope List<Position>();

		for (int32 i = 0; i < lines.Count; i++)
		{
			StringView line = lines[i];
			StringSplitEnumerator enumerator = line.Split(',');

			Position pos;
			pos.x = uint32.Parse(enumerator.GetNext());
			pos.y = uint32.Parse(enumerator.GetNext());

			positions.Add(pos);
		}

		int64 maximum = ComputeMaximumDimension(positions, isPartB);
		Console.WriteLine("Maximum is {}", maximum);
	}
}